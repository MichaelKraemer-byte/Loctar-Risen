<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: models/drawable-object.class.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: models/drawable-object.class.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>class DrawableObject {

    initialX = 0;
    x = 0;
    y = 280;
    img;
    height = 200;
    width = 200;
    imageCache = {};
    currentImage = 0;
    cooldown = false;
    RECHARGE_TIME = 500;
    currentImageIndex = 0;
    gameHasStarted = false;
    world;
    



/**
 * Draws a frame around the object for debugging purposes.
 * - Draws a green rectangle around the object's bounding box.
 * - Draws a red rectangle around the object's offset area.
 * 
 * @param {CanvasRenderingContext2D} ctx - The 2D rendering context of the canvas.
 */
 drawFrame(ctx) {
    if (this instanceof ThreeBlockPlatform || this instanceof Character || this instanceof Minotaur_1 || this instanceof Endboss || this instanceof ThrowableObject || this instanceof Axe) {
        ctx.beginPath();
        ctx.lineWidth = "4";
        ctx.strokeStyle = "green";
        ctx.rect(this.x, this.y, this.width, this.height);
        ctx.stroke();
    }

    // Offset rectangle form
    if (this instanceof ThreeBlockPlatform || this instanceof Character || this instanceof Minotaur_1 || this instanceof Endboss || this instanceof ThrowableObject || this instanceof Axe) {
        ctx.beginPath();
        ctx.lineWidth = "4";
        ctx.strokeStyle = "red";
        ctx.rect(
            this.x + this.offset.left,
            this.y + this.offset.top,
            this.width - this.offset.left - this.offset.right,
            this.height - this.offset.top - this.offset.bottom
        );
        ctx.stroke();
    }
}

/**
 * Draws the object on the canvas.
 * - Uses the object's image and draws it at the object's position with its width and height.
 * 
 * @param {CanvasRenderingContext2D} ctx - The 2D rendering context of the canvas.
 */
draw(ctx) {
    try {
        ctx.drawImage(this.img, this.x, this.y, this.width, this.height);
    } catch (e) {
        console.warn('Error loading image', e);
        console.log('Could not load image', this.img);
    }
}

/**
 * Loads an image from the specified path and assigns it to the object's `img` property.
 * 
 * @param {string} path - The path to the image file.
 */
loadImage(path) {
    this.img = new Image();
    this.img.src = path;
}

/**
 * Loads multiple images from an array of paths and caches them.
 * - Each image is cached in the `imageCache` property.
 * 
 * @param {string[]} array - An array of image file paths.
 */
 loadImages(array) {
    array.forEach((path) => {
        this.img = new Image();
        this.img.src = path;
        this.imageCache[path] = this.img;
    });
}

/**
 * Plays an animation by cycling through an array of image paths.
 * - Updates the object's image to the next one in the sequence.
 * 
 * @param {string[]} images - An array of image file paths for the animation.
 */
 playAnimation(images) {
    let i = this.currentImage % images.length;
    let path = images[i];
    this.img = this.imageCache[path];
    this.currentImage++;
}

/**
 * Plays a single frame of animation and stops at the latest image.
 * - Updates the object's image to the next one in the sequence and stops when the last image is reached.
 * 
 * @param {string[]} images - An array of image file paths for the animation.
 * @param {number} animationInterval - The interval ID for clearing the animation.
 */
 playSingleAnimation(images, animationInterval) {
    if (this.currentImageIndex &lt; images.length) {
        let path = images[this.currentImageIndex];
        this.img = this.imageCache[path];
        this.currentImageIndex++;
    } else {
        clearInterval(animationInterval); // Stop the animation when the last image is reached
    }
}

/**
 * Plays a single frame of animation and stops at the last image.
 * - Keeps the last image displayed after reaching the end of the animation sequence.
 * 
 * @param {string[]} images - An array of image file paths for the animation.
 */
playSingleAnimationAndStopAtLatestImage(images) {
    if (this.currentImage &lt; images.length) {
        let path = images[this.currentImage];
        this.img = this.imageCache[path];
        this.currentImage++;
    } else {
        // Keep the last image displayed when the end of the animation is reached
        let path = images[images.length - 1];
        this.img = this.imageCache[path];
    }
}

/**
 * Plays a sound with specified volume and playback speed.
 * - If global volume is enabled, the sound is played; otherwise, it is paused.
 * 
 * @param {HTMLAudioElement} audio - The audio element to play.
 * @param {number} volume - The volume level for the sound (0.0 to 1.0).
 * @param {number} audioSpeed - The playback speed for the sound (e.g., 1.0 for normal speed).
 */
playSound(audio, volume, audioSpeed) {
    if (globalVolume) {
        audio.volume = volume;
        audio.playbackRate = audioSpeed;
        audio.play();
    } else {
        audio.volume = volume;
        audio.playbackRate = audioSpeed;
        audio.pause();
    }
}

/**
 * Pauses the specified audio.
 * 
 * @param {HTMLAudioElement} audio - The audio element to pause.
 */
 pauseSound(audio) {
    audio.pause();
}

/**
 * Starts the cooldown period for the object.
 * - Sets a cooldown flag and schedules its reset after the specified recharge time.
 */
 startCooldown() {
    this.cooldown = true;
    setTimeout(() => {
        this.cooldown = false;
    }, this.RECHARGE_TIME);
}

/**
 * Checks if the object is currently in cooldown and starts the cooldown if not.
 */
checkAndStartCooldown() {
    if (!this.cooldown) {
        this.startCooldown();
    }
}

/**
 * Checks if the object is visible within the canvas viewport.
 * - Determines visibility based on the object's position and the camera's position.
 * 
 * @returns {boolean} `true` if the object is visible; otherwise, `false`.
 */
 isVisible() {
    if (this.world) {
        return this.x + this.width > -this.world.camera_x &amp;&amp; this.x &lt; -this.world.camera_x + this.world.canvas.width;
    }
    return false;
}

}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Events</h3><ul><li><a href="fullscreenContainer.html#event:click">click</a></li><li><a href="gameCanvas.html#event:mouseout-Hidesthefullscreenandsoundbuttoncontainers.">mouseout - Hides the fullscreen and sound button containers.</a></li><li><a href="jQuery.html#event:click">click</a></li><li><a href="soundButtonContainer.html#event:mouseout-Hidesthefullscreenandsoundbuttoncontainers.">mouseout - Hides the fullscreen and sound button containers.</a></li><li><a href="touchLeft.html#event:touchend">touchend</a></li><li><a href="touchLeft.html#event:touchstart">touchstart</a></li><li><a href="touchRight.html#event:touchend">touchend</a></li><li><a href="touchRight.html#event:touchstart">touchstart</a></li><li><a href="window.html#event:resize">resize</a></li></ul><h3>Global</h3><ul><li><a href="global.html#backToMenu">backToMenu</a></li><li><a href="global.html#checkAndStartBackgroundMusic">checkAndStartBackgroundMusic</a></li><li><a href="global.html#closePopUp">closePopUp</a></li><li><a href="global.html#disOrEnableOkButton">disOrEnableOkButton</a></li><li><a href="global.html#handleTouchEnd">handleTouchEnd</a></li><li><a href="global.html#handleTouchStart">handleTouchStart</a></li><li><a href="global.html#handleUserInteraction">handleUserInteraction</a></li><li><a href="global.html#hideContainer">hideContainer</a></li><li><a href="global.html#hideLandingScreen">hideLandingScreen</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#playAudio">playAudio</a></li><li><a href="global.html#playMenuTheme">playMenuTheme</a></li><li><a href="global.html#renderControls">renderControls</a></li><li><a href="global.html#resetGame">resetGame</a></li><li><a href="global.html#setupUserInteractionListener">setupUserInteractionListener</a></li><li><a href="global.html#showFirstPageHorizontalMobileControls">showFirstPageHorizontalMobileControls</a></li><li><a href="global.html#showFirstPageVerticalMobileControls">showFirstPageVerticalMobileControls</a></li><li><a href="global.html#showFullScreenContainer">showFullScreenContainer</a></li><li><a href="global.html#showLandingScreen">showLandingScreen</a></li><li><a href="global.html#showSecondPageHorizontalMobileControls">showSecondPageHorizontalMobileControls</a></li><li><a href="global.html#showSecondPageVerticalMobileControls">showSecondPageVerticalMobileControls</a></li><li><a href="global.html#slideInControls">slideInControls</a></li><li><a href="global.html#slideInFailureParchment">slideInFailureParchment</a></li><li><a href="global.html#slideInStory">slideInStory</a></li><li><a href="global.html#slideInSuccessParchment">slideInSuccessParchment</a></li><li><a href="global.html#slideInTurnDeviceNotice">slideInTurnDeviceNotice</a></li><li><a href="global.html#soundOnOrOff">soundOnOrOff</a></li><li><a href="global.html#startGame">startGame</a></li><li><a href="global.html#startResettedGame">startResettedGame</a></li><li><a href="global.html#updateFullscreenVisibility">updateFullscreenVisibility</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.3</a> on Sun Aug 18 2024 17:50:28 GMT+0200 (Central European Summer Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
